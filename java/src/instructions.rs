use crate::io::BinaryWriter;
use crate::{ClassFile, Descriptor};

#[derive(Debug)]
pub enum Ins {
    AALoad,
    AAStore,
    AConstNull,
    ALoad { local: u8 },
    ALoad0,
    ALoad1,
    ALoad2,
    ALoad3,
    ANewArray { index: usize },
    AReturn,
    ArrayLength,
    AStore { local: u8 },
    AStore0,
    AStore1,
    AStore2,
    AStore3,
    AThrow,
    BALoad,
    BAStore,
    BIPush { value: i8 },
    CALoad,
    CAStore,
    CheckCast { index: usize },
    D2F,
    D2I,
    D2L,
    DAdd,
    DALoad,
    DAStore,
    DCmpG,
    DCmpL,
    DConst0,
    DConst1,
    DDiv,
    DLoad { local: u8 },
    DLoad0,
    DLoad1,
    DLoad2,
    DLoad3,
    DMul,
    DNeg,
    DRem,
    DReturn,
    DStore { local: u8 },
    DStore0,
    DStore1,
    DStore2,
    DStore3,
    DSub,
    Dup,
    DupX1,
    DupX2,
    Dup2,
    Dup2X1,
    Dup2X2,
    F2D,
    F2I,
    F2L,
    FAdd,
    FALoad,
    FAStore,
    FCmpG,
    FCmpL,
    FConst0,
    FConst1,
    FConst2,
    FDiv,
    FLoad { local: u8 },
    FLoad0,
    FLoad1,
    FLoad2,
    FLoad3,
    FMul,
    FNeg,
    FRem,
    FReturn,
    FStore { local: u8 },
    FStore0,
    FStore1,
    FStore2,
    FStore3,
    FSub,
    GetField { index: usize },
    GetStatic { index: usize },
    Goto { branch: i16 },
    GotoW { branch: i32 },
    I2B,
    I2C,
    I2D,
    I2F,
    I2L,
    I2S,
    IAdd,
    IALoad,
    IAnd,
    IAStore,
    IConstM1,
    IConst0,
    IConst1,
    IConst2,
    IConst3,
    IConst4,
    IConst5,
    IDiv,
    IfACmpEq { branch: i16 },
    IfACmpNe { branch: i16 },
    IfICmpEq { branch: i16 },
    IfICmpNe { branch: i16 },
    IfICmpLt { branch: i16 },
    IfICmpGe { branch: i16 },
    IfICmpGt { branch: i16 },
    IfICmpLe { branch: i16 },
    IfEq { branch: i16 },
    IfNe { branch: i16 },
    IfLt { branch: i16 },
    IfGe { branch: i16 },
    IfGt { branch: i16 },
    IfLe { branch: i16 },
    IfNonNull { branch: i16 },
    IfNull { branch: i16 },
    IInc { local: u8, value: i8 },
    ILoad { local: u8 },
    ILoad0,
    ILoad1,
    ILoad2,
    ILoad3,
    IMul,
    INeg,
    InstanceOf { index: usize },
    InvokeDynamic { index: usize },
    InvokeInterface { index: usize, count: u8 },
    InvokeSpecial { index: usize },
    InvokeStatic { index: usize },
    InvokeVirtual { index: usize },
    IOr,
    IRem,
    IReturn,
    IShl,
    IShr,
    IStore { local: u8 },
    IStore0,
    IStore1,
    IStore2,
    IStore3,
    ISub,
    IUShr,
    IXor,
    Jsr { branch: i16 },
    JsrW { branch: i32 },
    L2D,
    L2F,
    L2I,
    LAdd,
    LALoad,
    LAnd,
    LAStore,
    LCmp,
    LConst0,
    LConst1,
    Ldc { index: usize },
    LdcW { index: usize },
    Ldc2W { index: usize },
    LDiv,
    LLoad { local: u8 },
    LLoad0,
    LLoad1,
    LLoad2,
    LLoad3,
    LMul,
    LNeg,
    LookupSwitch { default: i32, npairs: i32, pairs: Vec<(i32, i32)> }, // value, offset
    LOr,
    LRem,
    LReturn,
    LShl,
    LShr,
    LStore { local: u8 },
    LStore0,
    LStore1,
    LStore2,
    LStore3,
    LSub,
    LUShr,
    LXor,
    MonitorEnter,
    MonitorExit,
    MultiANewArray { index: usize, dimensions: u8 },
    New { index: usize },
    NewArray { atype: Descriptor },
    Nop,
    Pop,
    Pop2,
    PutField { index: usize },
    PutStatic { index: usize },
    Ret { local: u8 },
    Return,
    SALoad,
    SAStore,
    SIPush { value: i16 },
    Swap,
    TableSwitch { default: i32, low: i32, high: i32, offsets: Vec<i32> },
}

impl Ins {
    pub fn encode(&self, writer: &mut BinaryWriter, class: &ClassFile) {
        match self {
            Ins::Nop => writer.u8(0x00),
            Ins::AConstNull => writer.u8(0x01),
            Ins::IConstM1 => writer.u8(0x02),
            Ins::IConst0 => writer.u8(0x03),
            Ins::IConst1 => writer.u8(0x04),
            Ins::IConst2 => writer.u8(0x05),
            Ins::IConst3 => writer.u8(0x06),
            Ins::IConst4 => writer.u8(0x07),
            Ins::IConst5 => writer.u8(0x08),
            Ins::LConst0 => writer.u8(0x09),
            Ins::LConst1 => writer.u8(0x0a),
            Ins::FConst0 => writer.u8(0x0b),
            Ins::FConst1 => writer.u8(0x0c),
            Ins::FConst2 => writer.u8(0x0d),
            Ins::DConst0 => writer.u8(0x0e),
            Ins::DConst1 => writer.u8(0x0f),
            Ins::BIPush { value } => { writer.u8(0x10); writer.i8(*value); },
            Ins::SIPush { value } => { writer.u8(0x11); writer.i16(*value); },
            Ins::Ldc { index } => { writer.u8(0x12); writer.u8(class.constant_pool_index_to_encodable_index(*index) as u8); },
            Ins::LdcW { index } => { writer.u8(0x13); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::Ldc2W { index } => { writer.u8(0x14); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::ILoad { local } => { writer.u8(0x15); writer.u8(*local); },
            Ins::LLoad { local } => { writer.u8(0x16); writer.u8(*local); },
            Ins::FLoad { local } => { writer.u8(0x17); writer.u8(*local); },
            Ins::DLoad { local } => { writer.u8(0x18); writer.u8(*local); },
            Ins::ALoad { local } => { writer.u8(0x19); writer.u8(*local); },
            Ins::ILoad0 => writer.u8(0x1a),
            Ins::ILoad1 => writer.u8(0x1b),
            Ins::ILoad2 => writer.u8(0x1c),
            Ins::ILoad3 => writer.u8(0x1d),
            Ins::LLoad0 => writer.u8(0x1e),
            Ins::LLoad1 => writer.u8(0x1f),
            Ins::LLoad2 => writer.u8(0x20),
            Ins::LLoad3 => writer.u8(0x21),
            Ins::FLoad0 => writer.u8(0x22),
            Ins::FLoad1 => writer.u8(0x23),
            Ins::FLoad2 => writer.u8(0x24),
            Ins::FLoad3 => writer.u8(0x25),
            Ins::DLoad0 => writer.u8(0x26),
            Ins::DLoad1 => writer.u8(0x27),
            Ins::DLoad2 => writer.u8(0x28),
            Ins::DLoad3 => writer.u8(0x29),
            Ins::ALoad0 => writer.u8(0x2a),
            Ins::ALoad1 => writer.u8(0x2b),
            Ins::ALoad2 => writer.u8(0x2c),
            Ins::ALoad3 => writer.u8(0x2d),
            Ins::IALoad => writer.u8(0x2e),
            Ins::LALoad => writer.u8(0x2f),
            Ins::FALoad => writer.u8(0x30),
            Ins::DALoad => writer.u8(0x31),
            Ins::AALoad => writer.u8(0x32),
            Ins::BALoad => writer.u8(0x33),
            Ins::CALoad => writer.u8(0x34),
            Ins::SALoad => writer.u8(0x35),
            Ins::IStore { local } => { writer.u8(0x36); writer.u8(*local); },
            Ins::LStore { local } => { writer.u8(0x37); writer.u8(*local); },
            Ins::FStore { local } => { writer.u8(0x38); writer.u8(*local); },
            Ins::DStore { local } => { writer.u8(0x39); writer.u8(*local); },
            Ins::AStore { local } => { writer.u8(0x3a); writer.u8(*local); },
            Ins::IStore0 => writer.u8(0x3b),
            Ins::IStore1 => writer.u8(0x3c),
            Ins::IStore2 => writer.u8(0x3d),
            Ins::IStore3 => writer.u8(0x3e),
            Ins::LStore0 => writer.u8(0x3f),
            Ins::LStore1 => writer.u8(0x40),
            Ins::LStore2 => writer.u8(0x41),
            Ins::LStore3 => writer.u8(0x42),
            Ins::FStore0 => writer.u8(0x43),
            Ins::FStore1 => writer.u8(0x44),
            Ins::FStore2 => writer.u8(0x45),
            Ins::FStore3 => writer.u8(0x46),
            Ins::DStore0 => writer.u8(0x47),
            Ins::DStore1 => writer.u8(0x48),
            Ins::DStore2 => writer.u8(0x49),
            Ins::DStore3 => writer.u8(0x4a),
            Ins::AStore0 => writer.u8(0x4b),
            Ins::AStore1 => writer.u8(0x4c),
            Ins::AStore2 => writer.u8(0x4d),
            Ins::AStore3 => writer.u8(0x4e),
            Ins::IAStore => writer.u8(0x4f),
            Ins::LAStore => writer.u8(0x50),
            Ins::FAStore => writer.u8(0x51),
            Ins::DAStore => writer.u8(0x52),
            Ins::AAStore => writer.u8(0x53),
            Ins::BAStore => writer.u8(0x54),
            Ins::CAStore => writer.u8(0x55),
            Ins::SAStore => writer.u8(0x56),
            Ins::Pop => writer.u8(0x57),
            Ins::Pop2 => writer.u8(0x58),
            Ins::Dup => writer.u8(0x59),
            Ins::DupX1 => writer.u8(0x5a),
            Ins::DupX2 => writer.u8(0x5b),
            Ins::Dup2 => writer.u8(0x5c),
            Ins::Dup2X1 => writer.u8(0x5d),
            Ins::Dup2X2 => writer.u8(0x5e),
            Ins::Swap => writer.u8(0x5f),
            Ins::IAdd => writer.u8(0x60),
            Ins::LAdd => writer.u8(0x61),
            Ins::FAdd => writer.u8(0x62),
            Ins::DAdd => writer.u8(0x63),
            Ins::ISub => writer.u8(0x64),
            Ins::LSub => writer.u8(0x65),
            Ins::FSub => writer.u8(0x66),
            Ins::DSub => writer.u8(0x67),
            Ins::IMul => writer.u8(0x68),
            Ins::LMul => writer.u8(0x69),
            Ins::FMul => writer.u8(0x6a),
            Ins::DMul => writer.u8(0x6b),
            Ins::IDiv => writer.u8(0x6c),
            Ins::LDiv => writer.u8(0x6d),
            Ins::FDiv => writer.u8(0x6e),
            Ins::DDiv => writer.u8(0x6f),
            Ins::IRem => writer.u8(0x70),
            Ins::LRem => writer.u8(0x71),
            Ins::FRem => writer.u8(0x72),
            Ins::DRem => writer.u8(0x73),
            Ins::INeg => writer.u8(0x74),
            Ins::LNeg => writer.u8(0x75),
            Ins::FNeg => writer.u8(0x76),
            Ins::DNeg => writer.u8(0x77),
            Ins::IShl => writer.u8(0x78),
            Ins::LShl => writer.u8(0x79),
            Ins::IShr => writer.u8(0x7a),
            Ins::LShr => writer.u8(0x7b),
            Ins::IUShr => writer.u8(0x7c),
            Ins::LUShr => writer.u8(0x7d),
            Ins::IAnd => writer.u8(0x7e),
            Ins::LAnd => writer.u8(0x7f),
            Ins::IOr => writer.u8(0x80),
            Ins::LOr => writer.u8(0x81),
            Ins::IXor => writer.u8(0x82),
            Ins::LXor => writer.u8(0x83),
            Ins::IInc { local, value } => { writer.u8(0x84); writer.u8(*local); writer.i8(*value); },
            Ins::I2L => writer.u8(0x85),
            Ins::I2F => writer.u8(0x86),
            Ins::I2D => writer.u8(0x87),
            Ins::L2I => writer.u8(0x88),
            Ins::L2F => writer.u8(0x89),
            Ins::L2D => writer.u8(0x8a),
            Ins::F2I => writer.u8(0x8b),
            Ins::F2L => writer.u8(0x8c),
            Ins::F2D => writer.u8(0x8d),
            Ins::D2I => writer.u8(0x8e),
            Ins::D2L => writer.u8(0x8f),
            Ins::D2F => writer.u8(0x90),
            Ins::I2B => writer.u8(0x91),
            Ins::I2C => writer.u8(0x92),
            Ins::I2S => writer.u8(0x93),
            Ins::LCmp => writer.u8(0x94),
            Ins::FCmpL => writer.u8(0x95),
            Ins::FCmpG => writer.u8(0x96),
            Ins::DCmpL => writer.u8(0x97),
            Ins::DCmpG => writer.u8(0x98),
            Ins::IfEq { branch } => { writer.u8(0x99); writer.i16(*branch); },
            Ins::IfNe { branch } => { writer.u8(0x9a); writer.i16(*branch); },
            Ins::IfLt { branch } => { writer.u8(0x9b); writer.i16(*branch); },
            Ins::IfGe { branch } => { writer.u8(0x9c); writer.i16(*branch); },
            Ins::IfGt { branch } => { writer.u8(0x9d); writer.i16(*branch); },
            Ins::IfLe { branch } => { writer.u8(0x9e); writer.i16(*branch); },
            Ins::IfICmpEq { branch } => { writer.u8(0x9f); writer.i16(*branch); },
            Ins::IfICmpNe { branch } => { writer.u8(0xa0); writer.i16(*branch); },
            Ins::IfICmpLt { branch } => { writer.u8(0xa1); writer.i16(*branch); },
            Ins::IfICmpGe { branch } => { writer.u8(0xa2); writer.i16(*branch); },
            Ins::IfICmpGt { branch } => { writer.u8(0xa3); writer.i16(*branch); },
            Ins::IfICmpLe { branch } => { writer.u8(0xa4); writer.i16(*branch); },
            Ins::IfACmpEq { branch } => { writer.u8(0xa5); writer.i16(*branch); },
            Ins::IfACmpNe { branch } => { writer.u8(0xa6); writer.i16(*branch); },
            Ins::Goto { branch } => { writer.u8(0xa7); writer.i16(*branch); },
            Ins::Jsr { branch } => { writer.u8(0xa8); writer.i16(*branch); },
            Ins::Ret { local } => { writer.u8(0xa9); writer.u8(*local); },
            Ins::TableSwitch { default, low, high, offsets } => {
                writer.u8(0xaa);

                let pad = writer.len() % 4;
                if pad != 0 {
                    for _ in 0..4 - pad {
                        writer.u8(0);
                    }
                }

                writer.i32(*default);
                writer.i32(*low);
                writer.i32(*high);

                for offset in offsets {
                    writer.i32(*offset);
                }
            },
            Ins::LookupSwitch { default, npairs, pairs } => {
                writer.u8(0xab);

                let pad = writer.len() % 4;
                if pad != 0 {
                    for _ in 0..4 - pad {
                        writer.u8(0);
                    }
                }

                writer.i32(*default);
                writer.i32(*npairs);

                for pair in pairs {
                    writer.i32(pair.0);
                    writer.i32(pair.1);
                }
            },
            Ins::IReturn => writer.u8(0xac),
            Ins::LReturn => writer.u8(0xad),
            Ins::FReturn => writer.u8(0xae),
            Ins::DReturn => writer.u8(0xaf),
            Ins::AReturn => writer.u8(0xb0),
            Ins::Return => writer.u8(0xb1),
            Ins::GetStatic { index } => { writer.u8(0xb2); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::PutStatic { index } => { writer.u8(0xb3); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::GetField { index } => { writer.u8(0xb4); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::PutField { index } => { writer.u8(0xb5); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::InvokeVirtual { index } => { writer.u8(0xb6); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::InvokeSpecial { index } => { writer.u8(0xb7); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::InvokeStatic { index } => { writer.u8(0xb8); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::InvokeInterface { index, count } => {
                writer.u8(0xb9);
                writer.u16(class.constant_pool_index_to_encodable_index(*index));
                writer.u8(*count);
                writer.u8(0);
            },
            Ins::InvokeDynamic { index } => {
                writer.u8(0xba);
                writer.u16(class.constant_pool_index_to_encodable_index(*index));
                writer.u16(0);
            },
            Ins::New { index } => { writer.u8(0xbb); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::NewArray { atype } => { writer.u8(0xbc); writer.u8(match atype {
                Descriptor::Byte => 8,
                Descriptor::Char => 5,
                Descriptor::Double => 7,
                Descriptor::Float => 7,
                Descriptor::Int => 10,
                Descriptor::Long => 11,
                Descriptor::Reference(_) => panic!("Cannot invoke NewArray with Reference, use ANewArray instead"),
                Descriptor::Short => 9,
                Descriptor::Boolean => 4,
                Descriptor::Array(_, _) => panic!("Cannot invoke NewArray with Array, use MultiANewArray instead"),
                Descriptor::Void => panic!(),
            }); },
            Ins::ANewArray { index } => { writer.u8(0xbd); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::ArrayLength => writer.u8(0xbe),
            Ins::AThrow => writer.u8(0xbf),
            Ins::CheckCast { index } => { writer.u8(0xc0); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::InstanceOf { index } => { writer.u8(0xc1); writer.u16(class.constant_pool_index_to_encodable_index(*index)); },
            Ins::MonitorEnter => writer.u8(0xc2),
            Ins::MonitorExit => writer.u8(0xc3),
            Ins::MultiANewArray { index, dimensions } => {
                writer.u8(0xc5);
                writer.u16(class.constant_pool_index_to_encodable_index(*index));
                writer.u8(*dimensions);
            },
            Ins::IfNull { branch } => { writer.u8(0xc6); writer.i16(*branch); },
            Ins::IfNonNull { branch } => { writer.u8(0xc7); writer.i16(*branch); },
            Ins::GotoW { branch } => { writer.u8(0xc8); writer.i32(*branch); },
            Ins::JsrW { branch } => { writer.u8(0xc9); writer.i32(*branch); },
        }
    }
}